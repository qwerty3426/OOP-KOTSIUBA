# IndependentWork12: Дослідження продуктивності та безпеки PLINQ

## Скриншот запуску програми
![Скріншот](screenshot.png)

## Опис проєкту
Цей проєкт демонструє використання **PLINQ** (Parallel LINQ) у C# для підвищення продуктивності на великих колекціях даних.  
PLINQ дозволяє розподіляти обчислення між кількома потоками, що особливо ефективно для **обчислювально інтенсивних задач**, таких як перевірка чисел на простоту.

Проєкт також показує важливість **потокобезпечності**: при використанні паралельних операцій з побічними ефектами (зміна спільних змінних) можуть виникати некоректні результати.

---

## Проведені експерименти з продуктивності
- Колекції чисел розміром: **1 000 000**, **5 000 000**, **10 000 000** елементів.
- Обчислювальна операція: **перевірка числа на простоту (IsPrime)** для кожного елемента.
- Час виконання (приклад, мілісекунди):

| Розмір колекції | LINQ (ms) | PLINQ (ms) |
|-----------------|-----------|------------|
| 1 000 000       | 2200      | 800        |
| 5 000 000       | 11000     | 3200       |
| 10 000 000      | 23000     | 6500       |

### Аналіз продуктивності
- **PLINQ швидше**, коли обчислення важкі та колекції великі.  
- Для маленьких колекцій (1M) різниця менш помітна або навіть LINQ може бути швидше через накладні витрати на створення потоків.  
- Висновок: PLINQ ефективний для **масивних наборів даних та обчислювально інтенсивних задач**.

---

## Демонстрація побічних ефектів

### Некоректна сума без блокування
При спробі змінювати спільну змінну всередині PLINQ без синхронізації виникає **гонка даних**:

```csharp
int sum = 0;
numbers.AsParallel().ForAll(n => sum += n);
Console.WriteLine($"Некоректна сума (без lock): {sum}");
